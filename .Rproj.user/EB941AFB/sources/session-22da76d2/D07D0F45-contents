---
title: "Lab5_exercises"
format:
  html:
    embed-resources: true
editor: visual
execute:
  cache: false
---

1.  **What characterises the peptides binding to the HLAs?**

Peptides that bind to HLAs are characterized by specific amino acid anchor residues that fit into the corresponding pocket within the HLA binding cleft.

2.  **What characterises T-cell Receptors binding to the pMHC complexes?**

TCRs binding to pMHC complexes are characterized by specific affinities and kinetics, which are critical for T cell activation, as well as avidity, the combined strength of multiple TCR-pMHC interactions.

```{r}
#| message: false 
library("tidyverse")
```

```{r}
peptide_data <- read_csv(file = 'data/peptide-detail-ci.csv.gz', na = c('', 'N/A', 'NA'))
peptide_data
```

```{r}
meta_data <- read_csv(file = 'data/subject-metadata.csv', na = c('', 'N/A', 'NA'))
meta_data
```

```{r}
meta_data |> 
  slice_sample(n = 10)|> view()
```

-   **Q1: How many observations of how many variables are in the data?**

There are 10 observations and 30 variables.

-   **Q2: Are there groupings in the variables, i.e. do certain variables “go together” somehow?**

    Yes, they do. The ID, Cell type, age, gender, ethnicity, and HLA type all 'go together'.

-   **T1: Re-create this plot**

    ```{r}
    meta_data |>
      count(Cohort, Gender)|>filter(!is.na(Gender))|>
      ggplot(aes(x=Cohort, y=n, fill = Gender)) +
    geom_col(stat = 'identity', position = 'dodge', color ='black', alpha = 0.5) +  theme_minimal() +
        theme(legend.position = 'bottom') + 
      theme(axis.text.x = element_text(angle = 20, vjust = 1, hjust=1)) 
     

    # position = dodge (side by side)
    # position = stat (uno encima de otro)

    ```

-   **T2: Re-create this plot**

    ```{r}
    meta_data |>
      filter(!is.na(Gender)) |>
      mutate(
        Age_group = case_when(
          Age >= 20 & Age <=30 ~ "20-30",
          Age >= 30 & Age <= 40 ~ "30-40",
          Age >= 40 & Age <= 50 ~ "40-50",
          Age >= 50 & Age <= 60 ~ "50-60",
          Age >= 60 & Age <= 70 ~ "60-70",
          Age >= 70 & Age <= 80 ~ "70-80",
        )
      ) |>
      count(Gender, Age_group) |>
      ggplot(aes(x = Age_group, y = n, fill = Gender)) +
      geom_col(position = "dodge", color='black', alpha = 0.5) +  theme_minimal() + theme(legend.position = 'bottom') + labs(x = "Age_group", y = "n", fill = "Gender")
    ```

```{r}
meta_data |>
  filter(!is.na(Gender)) |>
  mutate(
    Age_group = cut_width(Age, width= 10, boundary = 0))|>
  count(Gender, Age_group) |>
  ggplot(aes(x = Age_group, y = n, fill = Gender)) +
  geom_col(position = "dodge", color = 'black', alpha = 0.5) +
  theme_minimal() + theme(legend.position = 'bottom') + labs(x = "Age_group", y = "n", fill = "Gender")

```

```{r}
#| label: Library load
#| eval: true
#| echo: true
#| message: false
meta_data |>
  filter(!is.na(Gender)) |>
  mutate(
    Age_group = cut_interval(Age, n = NULL, length = 10))|>
  count(Gender, Age_group) |>
  ggplot(aes(x = Age_group, y = n, fill = Gender)) +
  geom_col(position = "dodge", color = 'black', alpha = 0.5) +
  theme_minimal() + theme(legend.position = 'bottom') + labs(x = "Age_group", y = "n", fill = "Gender")
```

##### **STOP! Make sure you handled how `NA`s are denoted in the data before proceeding, see hint below T1**

-   **T3: Look at the data and create yet another plot as you see fit. Also skip the redundant variables `Subject`, `Cell Type` and `Target Type`**

```{r}
Meta_data_new <- meta_data |> select(-c('Cell Type', 'Target Type', 'Subject'))
Meta_data_new

```

```{r}
library("table1") # <= Yes, this should normally go at the beginning!
Meta_data_new|>
  mutate(Gender = factor(Gender),
         Cohort = factor(Cohort)) |>
  table1(x = formula(~ Gender + Age + Race | Cohort),
         data = _)
```

-   **T4: Create a new version of the `meta_data`, which with respect to allele-data only contains information on class I and also fix the odd naming, e.g. `HLA-A...9` becomes `A1` oand `HLA-A...10` becomes `A2` and so on for `B1`, `B2`, `C1` and `C2` (Think: How can we `rename` variables? And here, just do it “manually” per variable). Remember to assign this new data to the same `meta_data` variable**

```{r}
new_meta_data <- meta_data |> select(Experiment, Cohort, Gender, Age, Race, matches('^HLA-[ABC]')) |> rename( 
  A1 = 'HLA-A...9',
  A2 = 'HLA-A...10',
  B1 = 'HLA-B...11',
  B2 = 'HLA-B...12',
  C1 = 'HLA-C...13',
  C2 = 'HLA-C...14')
new_meta_data
```

Now let's try with peptide data

```{r}
peptide_data |> 
  slice_sample(n = 10)
```

-   **Q3: How many observations of how many variables are in the data?**

    ```{r}
    ncol(peptide_data)
    nrow(peptide_data)
    dim(peptide_data)
    ```

```{r}
peptide_data <- read_csv(file = 'data/peptide-detail-ci.csv.gz', na = c('', 'N/A', 'NA'))
peptide_data
```

-   **T5: As before, let’s immediately subset the `peptide_data` to the variables of interest: `TCR BioIdentity`, `Experiment` and `Amino Acids`. Remember to assign this new data to the same `peptide_data` variable to avoid cluttering your environment with redundant variables. Bonus: Did you know you can click the `Environment` pane and see which variables you have?**

```{r}
peptide_data <- peptide_data|>select(Experiment,`TCR BioIdentity`, `Amino Acids`)
peptide_data
```

-   **Q4: Is this tidy data? Why/why not?**

    Yes it is tidy data, since every variable have its own column and every observation has it own row.

-   **T6: See if you can find a way to create the below data, from the above**

    ```{r}
    peptide_data|> 
      separate(col = `TCR BioIdentity`, 
               into = c("CDR3b", "V_gene", "J_gene"), 
               sep = "\\+")
    ```

-   **T7: Add a variable, which counts how many peptides are in each observation of `Amino Acids.`**

    ```{r}
    peptide_data <- peptide_data|> 
      separate(col = `TCR BioIdentity`, 
               into = c("CDR3b", "V_gene", "J_gene"), 
               sep = "\\+")|> 
      mutate(peptide_count = str_count(`Amino Acids`, ',')+1)
    peptide_data

    ```

-   **T8. Re-create this plot:**

    ```{r}
    peptide_data |> 
      mutate(peptide_count = str_count(`Amino Acids`, ',')+1)|>
      mutate(peptide_count = 
               factor(peptide_count,
                levels = min(peptide_count):max(peptide_count)
                ))|> count(peptide_count, .drop=FALSE) |>
      ggplot(aes(x = peptide_count, y = n, color= 'black')) +
      geom_col(color = 'black', alpha = 0.5) +
      theme_minimal() + theme(legend.position = 'bottom') + labs(x = "Number of peptides per observation", y = "Count")

    ```

En R, un **factor** es un tipo especial de variable para representar **categorías** o **niveles** definidos, que guarda no solo los valores observados sino también un listado de todos los niveles posibles (aunque no aparezcan en los datos). Esto es útil porque permite controlar el orden y la presencia de categorías en tablas y gráficos. En nuestro caso, primero se convierte `peptide_count` en un factor con todos los niveles posibles usando `levels = min(peptide_count):max(peptide_count)`, lo que fuerza a R a reconocer todos los valores del mínimo al máximo aunque no existan en los datos. Después, al usar `count(peptide_count, .drop = FALSE)`, se le indica a `dplyr` que no elimine esos niveles vacíos, de modo que los valores sin observaciones aparecen igualmente en el resultado con `n = 0`. Esta combinación permite que `ggplot` muestre en el eje x todas las categorías, incluso aquellas con frecuencia cero.

-   **Q4: What is the maximum number of peptides assigned to one observation?**

    13

-   **T9: Using the `str_c()` and the `seq()` functions, re-create the below**

```{r}
seq(1:5)
str_c('peptide_', 1:5)
```

-   **T10: Use, what you learned about separating in T6 and the vector-of-strings you created in T9 adjusted to the number from Q4 to create the below data**

```{r}
peptide_data|> 
  separate(col = `Amino Acids`, 
           into = str_c('peptide_', 1:13))
```

-   **Q5: Now, presumable you got a warning, discuss in your group why that is?**

-   **Q6: With respect to `peptide_n`, discuss in your group, if this is wide- or long-data?**

This is wide data.

Wide data means each subject or observation is stored in one row and repeated measurements go across several columns (e.g., `peptide_1`, `peptide_2`, `peptide_3`). Long data means those repeated measurements are stacked in rows so each row represents one measurement for one subject (with extra columns like “peptide number” and “peptide”). Wide format is easier for viewing everything about one subject at once, while long format is easier for analysis and plotting in R.

![](images/clipboard-1966971883.png)

-   **T11: Using the `peptide_data`, run a few `slice_sample()` calls with varying degree of `n` to make sure, that you get a feeling for what is going on**

```{r}
peptide_data|> 
  separate(col = `Amino Acids`, 
           into = str_c('peptide_', 1:13))|> slice_sample(n=10)
```

-   **T12: From the `peptide_data` data above, with peptide_1, peptide_2, etc. create this data set using one of the data pivoting functions. Remember to start initially with sampling a smaller data set and then work on that first! Also, once you’re sure you’re good to go, reuse the `peptide_data` variable as we don’t want huge redundant data sets floating around in our environment**

    ```{r}
    long_peptide_data <- peptide_data|> 
      separate(col = `Amino Acids`, 
               into = str_c('peptide_', 1:13))|>
      
      pivot_longer(cols = c(peptide_1 : peptide_13),
                   names_to = 'peptide_n',
                   values_to = 'peptide')
    long_peptide_data
    ```

<!-- -->

-   **Q7: You will see some `NA`s in the `peptide` variable, discuss in your group from where these arise?**

The NAs appear because some peptide values are missing in the original dataset, and pivoting makes these missing entries more explicit.

-   **Q8: How many rows and columns now and how does this compare with Q3? Discuss why/why not it is different?**

    ```{r}
    dim(long_peptide_data)
    ```

There are 7 columns and 2006160 rows. After applying `pivot_longer()`, your dataset is reshaped from wide to long format. In the wide version, each sample or TCR has a single row with many peptide columns (`peptide_1`, `peptide_2`, …). `pivot_longer()` stacks those columns into two new columns — one indicating the peptide number and one containing the peptide value — so the **number of columns stays about the same** (you swap many peptide columns for just two). However, the **number of rows increases** because each peptide for a given sample now occupies its own row instead of all peptides being in the same row. This is the essence of wide-to-long transformation: the same information is preserved but reorganized so repeated measurements are rows instead of columns.

-   **T13: Now, lose the redundant variables `n_peptides` and `peptide_n`, get rid of the `NA`s in the `peptide` column, and make sure that we only have unique observations (i.e. there are no repeated rows/observations).**

```{r}
long_peptide_data <- long_peptide_data |>
  filter(!is.na(peptide))|> select(Experiment,CDR3b,V_gene,J_gene,peptide)
long_peptide_data
```

-   **Q8: Now how many rows and columns and is this data tidy? Discuss in your group why/why not?**

    ```{r}
    dim(long_peptide_data)
    ```

<!-- -->

-   **T14: Use the `str_detect()` function to `filter` the `CDR3b` and `peptide` variables using a `pattern` of `[^ARNDCQEGHILKMFPSTWYV]` and then play with the `negate` parameter so see what happens**

    ```{r}
    long_peptide_data <- long_peptide_data |>
    filter(str_detect(peptide,'^[ARNDCQEGHILKMFPSTWYV]', negate = FALSE) &
    str_detect(CDR3b, '^[ARNDCQEGHILKMFPSTWYV]', negate = FALSE))
    long_peptide_data
    ```

<!-- -->

-   **T15: Add two new variables to the data, `k_CDR3b` and `k_peptide` each signifying the length of the respective sequences**

    ```{r}
    long_peptide <- long_peptide_data|> mutate(
      k_CDR3b = str_length(CDR3b),
      k_peptide = str_length(peptide)
    )
    long_peptide
    ```

<!-- -->

-   **T16: Re-create this plot**

    ```{r}
    long_peptide|>
      count(k_CDR3b) |>
      ggplot(aes(x = k_CDR3b, y = n)) +
      geom_col(position = "dodge", color = 'black', alpha = 0.5) +
      theme_minimal() + theme(legend.position = 'bottom') + labs(x = "k_CDR3b", y = "count")
    ```

<!-- -->

-   **Q9: What is the most predominant length of the CDR3b-sequences?**

```{r}
long_peptide |>
count(k_CDR3b) |> 
slice_max(n, n = 1) 
```

-   **T17: Re-create this plot**

    ```{r}
    long_peptide|>
      count(k_peptide) |>
      ggplot(aes(x = k_peptide, y = n)) +
      geom_col(position = "dodge", color = 'black', alpha = 0.5) +
      theme_minimal() + theme(legend.position = 'bottom') + labs(x = "k_peptide", y = "count")
    ```

<!-- -->

-   **Q10: What is the most predominant length of the peptide-sequences?**

    ```{r}
    long_peptide |>
    count(k_peptide) |> 
    slice_max(n, n = 1) 
    ```

<!-- -->

-   **Q11: Discuss in your group, if this data set is tidy or not?**

This tibble is already tidy. Each column represents a single variable , and each row represents a single observation .

```{r}
new_meta_data 

```

**Q12: Discuss in your group, if this data with respect to the `A1`, `A2`, `B1`, `B2`, `C1` and `C2` variables is a wide or a long data format?**

It is wide data

-   **T18: use either `pivot_wider()` or `pivot_longer()` to create the following data:**

    ```{r}
    meta_data <-  new_meta_data |>
      pivot_longer(cols = c(A1 : C2),
                   names_to = 'Gene',
                   values_to = 'allele')

    meta_data
    ```

<!-- -->

-   **Q13: Discuss in your group, which variable(s?) define the same observations between the `peptide_data` and the `meta_data`?**

    ```{r}
    meta_data <- meta_data |>
      select(c('Experiment', 'allele'))
    meta_data

    ```

<!-- -->

-   **T19: Create the following data, according to specifications above:**

    ```{r}
    meta_data <- meta_data |>
      mutate(Allele_F_1_2 = str_sub(allele, 1,7))
    meta_data
    ```

<!-- -->

-   **T20: Clean the data a bit more, by removing the asterisk and redundant variables:**

    ```{r}
    meta_data <- meta_data|> mutate(
      Allele_F_1_2 = str_remove(Allele_F_1_2,'\\*'),
      allele = str_remove(allele, '\\*')
    )|>select(Experiment, allele ,Allele_F_1_2)
    meta_data
    ```

```{r}
long_peptide |>
  slice_sample(n = 10)
```

-   **T21: Create a `dplyr` pipeline, starting with the `peptide_data`, which joins it with the `meta_data` and remember to make sure that you get only unqiue observations of rows. Save this data into a new variable names `peptide_meta_data` (If you get a warning, discuss in your group what it means?)**

    ```{r}
    peptide_meta_data <- long_peptide|> left_join(meta_data)
    ```

Joining with \`by = join_by(Experiment)\`Warning: Detected an unexpected many-to-many relationship between \`x\` and \`y\`

```{r}
peptide_meta_data
```

### **Analysis**

Now, that we have the data in a prepared and ready-to-analyse format, let us return to the two burning questions we had:

1.  What characterises the peptides binding to the HLAs?

2.  What characterises T-cell Receptors binding to the pMHC-complexes?

    -   **T22: Subset the final `peptide_meta_data` data to `A02:01` and unique observations of peptides of length 9 and re-create the below sequence logo**

```{r}
library(dplyr)
library(ggseqlogo)
peptide_meta_data|> filter(allele == 'A02:01')|> filter(str_length(peptide) == 9) |> distinct(peptide) |> pull(peptide) |>  ggseqlogo()   

#distinct() es para que el programa te de secuencias únicas, es decir, que no se repitan

```

-   **T23: Repeat for e.g. `B07:02` or another of your favourite alleles**

    ```{r}
    peptide_meta_data|> filter(allele == 'B07:02')|> filter(str_length(peptide) == 9) |> distinct(peptide) |> pull(peptide) |>  ggseqlogo()  
    ```

-   **Q14: Which positions in the peptide determines binding to HLA?**

    Positions 2 and 9

    In a sequence logo, the height of the letters at each position reflects how conserved that amino acid is across all peptides, with highly conserved positions indicating key “anchor” residues that interact with the HLA binding pocket. In your logo for HLA-B07:02, positions 2 and 9 show the tallest, most consistent letters, meaning these sites are highly conserved and therefore the main determinants of binding specificity to the HLA molecule, while the other positions are more variable and contribute less directly to binding.

#### CDR3b-sequences binding to pMHC

-   **T24: Subset the `peptide_meta_data`, such that the length of the CDR3b is 15, the allele is A02:01 and the peptide is LLFLVLIML and re-create the below sequence logo of the CDR3b sequences:**

    ```{r}
    peptide_meta_data|> filter(str_length(CDR3b)== 15)|> filter(allele=='A02:01')|> filter(peptide=='LLFLVLIML') |> pull(CDR3b) |>  ggseqlogo()  
    ```

<!-- -->

-   **Q15: In your group, discuss what you see?**

The CDR3b sequence exhibit big picks in the first four positions, which describes a highly conserved N-terminal motif, determined by CASS (cysteine, alanine, serine, serine). The positions from 5 to 11 show small picks. At the end of the sequence (C-terminal), there are also high picks, which means that some conservation shows up again. The color code indicates the chemical nature of the amino acids.

-   **T25: Play around with other combinations of `k_CDR3b`, `Allele`, and `peptide` and inspect how the logo changes**

    ```{r}
    peptide_meta_data|> filter(str_length(CDR3b)== 15)|> filter(allele=='B35:03')|> filter(peptide=='ADAGFIKQY') |> pull(CDR3b) |>  ggseqlogo()  
    ```
